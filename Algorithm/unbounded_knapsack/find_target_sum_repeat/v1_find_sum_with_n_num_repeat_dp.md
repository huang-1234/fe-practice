### 题目分析

**输入输出**

* 输入：
  * `nums`：不重复的整数数组（元素为正整数且无重复）
  * `target`：自然数目标值（正整数）
* 输出：
  * 数组中数字和等于目标值的组合数量（数字可重复使用）
* 边界条件：
  * `1 <= nums.length <= 200`
  * `1 <= nums[i] <= 1000`
  * `1 <= target <= 5000`

**关键示例**

1. **基础案例**
   `nums = [1,2,3], target = 4` → 输出 `4`
   组合：`[1,1,1,1]`, `[1,1,2]`, `[1,3]`, `[2,2]`
2. **零钱兑换案例**
   `nums = [2], target = 3` → 输出 `0`（无法组合）
3. **单数字复用案例**
   `nums = [3], target = 6` → 输出 `1`（[3,3]）

**题目本质**
零钱兑换问题（组合求和）：

* 完全背包问题动态规划解法
* 数字可重复使用（物品无限供应）
* 求组合数而非排列数

---

### 解题策略

**算法选择**

* **动态规划（完全背包问题）**：
  * `dp[i]` 表示组成和 `i` 的组合数量
  * 状态转移：`dp[i] += dp[i - num]`
* **关键点**：
  外层遍历物品（数组元素），内层遍历背包容量（目标值），保证组合不重复计数（[1,2] 和 [2,1] 视为同一种）

**JS特性应用**

1. 初始化数组：`new Array(target+1).fill(0)`
2. 大数处理：JS自动处理整数运算（范围内无溢出风险）

**时空复杂度**

* 时间：**O**(**n**×**t**a**r**g**e**t**)**（n为数组长度）
* 空间：**O**(**t**a**r**g**e**t**)**

---

### 代码实现

```
const combinationSumCount = (nums, target) => {
    // 初始化dp数组：dp[i]表示组成和为i的组合数
    const dp = new Array(target + 1).fill(0);
    dp[0] = 1;  // 目标为0的组合数：空集（即1种）

    // 外层遍历数组元素（物品）
    for (const num of nums) {
        // 内层遍历背包容量（目标值）
        for (let i = num; i <= target; i++) {
            // 状态转移：组合数累加
            dp[i] += dp[i - num];
        }
    }

    return dp[target];
};
```

**关键代码说明**


| 代码片段                  | 作用                                                           |
| ------------------------- | -------------------------------------------------------------- |
| `dp[0] = 1`               | 空集是唯一和为0的组合（关键初始条件）                          |
| `for (const num of nums)` | 固定物品遍历顺序避免重复组合（[1,2]和[2,1]视为相同）           |
| `dp[i] += dp[i - num]`    | 核心状态转移：当前组合数 = 不使用num的组合数 + 使用num的组合数 |
| `i <= target`             | 仅当当前数小于目标值时参与计算（剪枝）                         |

---

### 测试验证

**测试用例设计**

```
console.log(combinationSumCount([1,2,3], 4));   // 4
console.log(combinationSumCount([2], 3));       // 0
console.log(combinationSumCount([3], 6));       // 1
console.log(combinationSumCount([1,2], 10));    // 6（全1组合+含2组合）

// 边界测试
console.log(combinationSumCount([10], 10));     // 1（[10]）
console.log(combinationSumCount([1], 1));       // 1（[1]）
console.log(combinationSumCount([100], 50));    // 0（无法组合）
```

**执行过程演示（nums=[1,2], target=3）**


| dp状态                                    | i=0 | i=1 | i=2 | i=3 |
| ----------------------------------------- | --- | --- | --- | --- |
| 初始                                      | 1   | 0   | 0   | 0   |
| num=1后                                   | 1   | 1   | 1   | 1   |
| num=2后                                   | 1   | 1   | 2   | 2   |
| 结果：`dp[3]=2`对应组合`[1,1,1]`和`[1,2]` |     |     |     |     |

---

### 优化反思

1. **组合与排列的区分**
   * 当前解法统计组合数（如 [1,2] 和 [2,1] 算1种）
   * 若要统计排列数（视为不同），需调换循环顺序：
     ```
     for (let i = 1; i <= target; i++) {
         for (const num of nums) {
             if (i >= num) dp[i] += dp[i - num];
         }
     }
     ```
2. **降维优化**
   * 当 `target` 极大时，可考虑滚动数组优化空间
   * 但因空间复杂度已是 **O**(**t**a**r**g**e**t**)**，实际需求中足够高效
3. **剪枝策略**
   * 若数组有序，可在外层循环增加条件：

     ```
     if (num > target) break;  // 跳过大于目标值的数字
     ```

     进一步提升效率（需先排序）
4. **大数处理**
   * 当结果可能很大时（如 `target=5000, nums=[1]`），
     需考虑使用 `BigInt`（本题约束范围内无需）

> 此解法完美契合零钱兑换类问题本质（LeetCode 518），通过动态规划高效计算组合数，避免回溯法的高指数复杂度。
>
