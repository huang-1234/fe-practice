// printf("Enter a number: ");
// // %f 匹配浮点型数据
// scanf("%f", &f);
// printf("Value = %f", f);
/* 子串翻转
时间限制： 4000MS 内存限制： 786432KB 题目描述：
    小美有一个由小写字母组成的字符串。小美认为字母表很有意思。所以他规定，在小写字母中，每个字母的后继就是字母表中这个字母的后一个，比如a的后继是b，b的后继是c。而字母表中的最后一个字母是z，为了防止z没有后继，小美又规定z的后继是a。这样字母的后继就形成了一个闭环。

    现在小美想要让字符串发生变化。所以他每次会给出一个区间和一个数k，并且让区间中所有的字母变成他们的第k个后继。第k个后继即让后继操作进行k次，比如a的2级后继是c，a的26级后继是a。

    现在小美记下来了操作序列和操作完之后得到的字符串。请你还原原来的字符串。

    输入描述
        第一行一个长度为n(1≤n≤105) 的字符串，代表操作完成之后得到的字符串。

    第二行一个数q(1≤q≤105) ，代表操作次数。

    接下来q行，每行三个数l,
    r, k(1≤l≤r≤n, 1≤k≤109)。代表区间的左右端点和第k级后继。

    输出描述 输出一个字符串，代表操作之前小美的字符串。

    样例输入 abcdefg 3 1 3 1 2 4 1 3 5 2 样例输出 zzyacfg

    提示 第一次操作后：aazacfg

    第二次操作后：ababcfg

    第三次操作后：abcdefg */
#include <stdio.h>
int main(){
  char string[];
  


  int n;
  scanf('%d', n);
  int const nRow = n;
  int a[3][nRow];
  
  for (int i = 0; i < 3;++i){
    for (int j = 0; j < nRow; ++j){
      scanf('%d', a[i][j]);
    }
  }
  while (n--){

  }
}